# CLAUDE.md

This file provides guidance to Claude Code или CODEX when working with code in this repository.

## ВАЖНО: Обновление документации

**ОБЯЗАТЕЛЬНО НАДО ПЕРИОДИЧЕСКИ ОБНОВЛЯТЬ И ДОБАВЛЯТЬ ИНФОРМАЦИЮ В ЭТОТ ФАЙЛ И СЛЕДИТЬ ЗА ТЕМ, ЧТОБЫ ИНФОРМАЦИЯ НЕ ПРОТИВОРЕЧИЛА РЕАЛЬНОСТИ И ПРОЧИМ ДОКУМЕНТАЦИЯМ**

## Обзор проекта

Автоматизированная система для парсинга объявлений с Авито по артикулам с многоуровневой валидацией и распределенной обработкой через независимые воркеры.

**Основные принципы:**
- Никогда не врать - если что-то неизвестно, так и говорить
- Добавлять небольшие, но понятные комментарии в код
- При необходимости использовать web search
- Не создавать версии проекта и не упоминать версионирование
- Всегда актуализировать документацию в [docs/doc.md](docs/doc.md)

**Основные возможности:**
- Массовый парсинг объявлений по списку артикулов
- Двухуровневая валидация (механическая + ИИ)
- Автоматическое определение неоригинальных товаров
- Ценовой анализ и фильтрация подозрительных предложений
- Сохранение детальной информации о каждом объявлении
- Автоматическое решение капчи
- Работа через прокси с автоматической ротацией

## Технологический стек

- **PostgreSQL** - основная БД для очередей и хранения данных
- **avito-library** - специализированная библиотека для парсинга на базе Playwright (КРИТИЧЕСКАЯ зависимость)
- **Docker + Docker Compose** - контейнеризация и оркестрация
- **Python 3.11+** - минимальная требуемая версия
- **asyncpg** - асинхронный драйвер PostgreSQL
- **Gemini 2.5-flash** - ИИ-валидация через OpenAI-совместимый API

Все зависимости должны быть максимальных версий.

## Структура проекта

**ВАЖНО:** Проект состоит из двух основных папок: `container` и `scripts`

```
/root/avito_zamer_complex-1/
├── container/          # Реализация Docker-воркера
│   ├── worker/        # Ядро логики воркера
│   │   ├── config.py          # Конфигурация из переменных окружения
│   │   ├── database.py        # 12 атомарных операций с БД
│   │   ├── browser.py         # Управление Playwright браузером
│   │   ├── main.py            # Основной цикл воркера
│   │   ├── errors.py          # Кастомные исключения
│   │   ├── stopwords.py       # Списки стоп-слов
│   │   └── validation/        # Двухуровневая валидация
│   │       ├── mechanical.py  # Стоп-слова + ценовой фильтр
│   │       └── ai.py          # ИИ-валидация через Gemini
│   ├── supervisor.py           # Менеджер multiprocessing
│   ├── healthcheck.sh          # Мониторинг здоровья
│   ├── check_dependencies.py  # Проверка зависимостей
│   └── Dockerfile
├── scripts/           # Локальные скрипты управления
│   ├── add_tasks.py          # Загрузка артикулов из data/urls.txt
│   ├── manage_proxies.py     # Загрузка прокси из data/proxies.txt
│   ├── monitor.py            # Мониторинг системы
│   ├── clear_database.py     # Интерактивная очистка таблиц
│   ├── check_queue.py        # Проверка статуса очереди
│   ├── free_proxies.py       # Освобождение заблокированных прокси
│   └── db_utils.py           # Общие утилиты БД
└── docs/doc.md       # Полная спецификация алгоритмов
```

## Основные команды

### Операции с Docker

**КРИТИЧЕСКИ ВАЖНО:** Все команды docker compose ДОЛЖНЫ выполняться ТОЛЬКО из корня проекта (`/root/avito_zamer_complex-1/`)

```bash
# Сборка контейнера
docker compose build

# Запуск контейнера
docker compose up -d

# Просмотр логов
docker compose logs -f

# Остановка контейнера
docker compose down
```

### Локальные скрипты управления

Все скрипты работают в интерактивном режиме с батчевыми операциями (1000 записей) и атомарными транзакциями.

```bash
# Загрузка артикулов (из scripts/data/urls.txt)
cd /root/avito_zamer_complex-1
python scripts/add_tasks.py

# Управление прокси (из scripts/data/proxies.txt)
python scripts/manage_proxies.py

# Мониторинг состояния системы
python scripts/monitor.py

# Очистка таблиц БД
python scripts/clear_database.py

# Проверка статуса очереди
python scripts/check_queue.py

# Освобождение заблокированных прокси
python scripts/free_proxies.py
```

### Конфигурация окружения

Настройка через файл `.env` в корне проекта:

```bash
# Подключение к БД
DB_HOST=81.30.105.134
DB_PORT=5417
DB_NAME=system_avito_zamer
DB_USER=admin
DB_PASSWORD=<пароль>

# Настройки воркеров
NUM_WORKERS=15              # Количество процессов воркеров
HEARTBEAT_INTERVAL=120      # Интервал обновления heartbeat (секунды)
STUCK_TASK_TIMEOUT=3600     # Таймаут для определения зависшей задачи (секунды)
MAX_RETRY_ATTEMPTS=3        # Максимум попыток на задачу

# ИИ-валидация
GEMINI_API_KEY=<ваш_ключ>   # Требуется для ИИ-валидации
```

## Архитектура

### Компоненты системы

- **Локальные скрипты** - управление задачами, прокси, мониторинг
- **Контейнеризированные воркеры** - выполнение парсинга на серверах
- **PostgreSQL БД** - централизованное хранилище данных и очередь задач
- **Avito Library** - основной инструмент взаимодействия с сайтом

### Принцип работы

1. Локальные скрипты загружают артикулы и прокси в БД
2. Воркеры асинхронно берут задачи из очереди
3. Каждый воркер независимо обрабатывает свои задачи
4. Результаты сохраняются в БД с полной историей валидации

### Архитектура multiprocessing

**Один контейнер + множество воркеров:**
- ОДИН Docker контейнер запускает supervisor.py
- Supervisor управляет N процессами воркеров через multiprocessing (по умолчанию: 15)
- Каждый процесс - независимый асинхронный воркер (asyncio)
- Автоматический перезапуск упавших воркеров
- Каждый воркер получает свой виртуальный дисплей (Xvfb) для браузеров

**Важно:** НЕ 15 контейнеров - ОДИН контейнер с 15 процессами внутри.

### Схема базы данных

Пять основных таблиц:
- `tasks` - артикулы для парсинга (статусы: 'новая', 'в работе', 'завершена', 'ошибка')
- `proxies` - пул прокси (статусы: 'свободен', 'используется', 'заблокирован')
- `parsed_cards` - данные спаршенных объявлений
- `validation_results` - результаты валидации (механическая + ИИ)
- `processed_articles` - история обработки

**Важно:** Все статусы в БД - на русском языке согласно схеме.

### Процесс работы воркера

1. **Инициализация** - Проверка зависимостей (avito-library ОБЯЗАТЕЛЬНА, режима заглушки нет)
2. **Восстановление зависших задач** - Возврат задач с heartbeat > 1 часа в очередь (с учетом MAX_RETRY_ATTEMPTS)
3. **Атомарное взятие задачи** - `FOR UPDATE SKIP LOCKED` предотвращает коллизии
4. **Атомарное взятие прокси** - Случайный выбор из доступных (если прокси еще нет)
5. **Запуск браузера** - Playwright с прокси, переиспользуется между задачами (если браузер еще не запущен)
6. **Переход на каталог** - Переход на страницу поиска Авито, вызов детектора, обработка капчи/блокировки
7. **Запуск heartbeat** - Фоновая задача обновления heartbeat каждые 120с
8. **Парсинг каталога** - Парсинг ВСЕХ страниц (без ограничений) через паттерн оркестратор-координатор:
   - Оркестратор парсит страницы каталога
   - Координатор обрабатывает ошибки (смена прокси при 403/407, решение капчи)
9. **Двухуровневая валидация**:
   - Механическая: стоп-слова + ценовой фильтр (порог 50%)
   - ИИ: анализ через Gemini 2.5-flash (порог 70%)
   - Сохранение всех результатов в БД
10. **Детальный парсинг карточек** - Парсинг отдельных объявлений, прошедших обе валидации:
    - Переход на страницу объявления
    - Вызов детектора + обработка капчи/блокировки
    - Парсинг детальных данных (дата публикации, местоположение, просмотры, характеристики)
    - При фатальных ошибках - проверка MAX_RETRY_ATTEMPTS
11. **Завершение задачи** - Обновление статуса "завершена", сохранение в processed_articles
12. **Переиспользование ресурсов** - Браузер и прокси остаются для следующей задачи (если не было ошибок)
13. **Возврат к шагу 3** - Взятие следующей задачи из очереди

### Критические технические требования

**ОБЯЗАТЕЛЬНО:**
- Использовать Avito Library для ВСЕХ операций с сайтом
- Максимально долгое переиспользование браузерной страницы
- Независимая работа воркеров без взаимной блокировки
- Атомарное взятие задач и прокси из БД (`FOR UPDATE SKIP LOCKED`)
- Heartbeat механизм для отслеживания живых воркеров (каждые 120с)
- Вызов детектора после КАЖДОГО перехода на страницу
- Использовать `headless=false` для браузера
- Проект состоит из двух папок: container и scripts
- Русские значения статусов в операциях с БД

**КРИТИЧЕСКИ ВАЖНО - Логика работы с прокси:**
- Блокировать прокси ТОЛЬКО при детекторах PROXY_BLOCK_403_DETECTOR_ID или PROXY_AUTH_DETECTOR_ID
- Освобождать прокси при ВСЕХ других ошибках (браузер, timeout, капча)
- НЕ блокировать прокси при технических проблемах (память, Playwright, сеть)
- Проверять MAX_RETRY_ATTEMPTS для ВСЕХ этапов (каталог + детальный парсинг)

**Валидация:**
- Механическая проверка на стоп-слова (б/у, аналог, не оригинал)
- Ценовой фильтр: отсечение объявлений дешевле 50% от топ-20%
- ИИ-валидация всех прошедших механическую проверку
- Сохранение результатов валидации в JSON для аудита

**Ограничения:**
- НЕ поддерживается частичный парсинг каталога
- НЕ поддерживается параллельный парсинг одного артикула
- НЕ восстанавливаются заблокированные прокси
- НЕ используется батчевая обработка для ИИ-валидации

### Управление ресурсами

**Переиспользование браузера:** Экземпляр Page переиспользуется между задачами до:
- Блокировки прокси (403/407)
- Нерешаемой капчи
- Остановки воркера

**Пулы соединений:**
- На воркер: 2-5 соединений (POOL_MIN_SIZE/POOL_MAX_SIZE)
- Всего: NUM_WORKERS × POOL_MAX_SIZE < 100 (лимит PostgreSQL)
- По умолчанию: 15 воркеров × 5 = 75 соединений

**Память:**
- shm_size: 6GB для 15 браузеров Chromium
- Каждый браузер: ~300-400MB на пиках

### Обработка ошибок

**КРИТИЧЕСКИ ВАЖНО: Логика блокировки/освобождения прокси**

**Прокси БЛОКИРУЮТСЯ (статус "заблокирован") ТОЛЬКО при:**
- Детектор вернул `PROXY_BLOCK_403_DETECTOR_ID` - Авито заблокировал этот IP (403)
- Детектор вернул `PROXY_AUTH_DETECTOR_ID` - ошибка авторизации прокси (407)

**Прокси ОСВОБОЖДАЮТСЯ (статус "свободен") при:**
- Ошибке запуска браузера (может быть нехватка памяти, проблемы Playwright - не вина прокси)
- Timeout перехода на страницу (проблемы сети, не факт что прокси плохой)
- Капча не решена (прокси работает, просто капча сложная или сервис недоступен)
- Graceful shutdown (воркер останавливается штатно)
- Любые другие ошибки НЕ связанные с блокировкой Авито

**Фатальные ошибки - прокси заблокирован (403/407):**
1. Блокировка прокси в БД (статус "заблокирован")
2. Закрытие браузера
3. Возврат задачи в очередь с инкрементом retry
4. Проверка счетчика retry:
   - Если retry_count >= MAX_RETRY_ATTEMPTS (3) → пометить задачу "ошибка"
   - Иначе → задача будет взята снова с новым прокси
5. Получение нового прокси и задачи

**Фатальные ошибки - капча не решена:**
1. ОСВОБОЖДЕНИЕ прокси (статус "свободен") - прокси НЕ виноват!
2. Закрытие браузера
3. Возврат задачи в очередь с инкрементом retry
4. Проверка счетчика retry (аналогично выше)

**Ошибки браузера (запуск, timeout, Playwright errors):**
1. ОСВОБОЖДЕНИЕ прокси (статус "свободен") - может быть не вина прокси
2. Закрытие браузера (если был запущен)
3. Возврат задачи в очередь с инкрементом retry
4. Проверка лимитов:
   - Для catalog goto errors: GOTO_FAILURE_LIMIT (5 попыток)
   - Для общих ошибок: MAX_RETRY_ATTEMPTS (3 попытки)

**Исчерпаны попытки (3 retry для задачи или 5 для goto):**
- Пометить задачу как 'ошибка'
- Больше не пытаться обработать этот артикул
- Задача останется в БД со статусом "ошибка" для анализа

**Нет доступных ресурсов:**
- Нет прокси: возврат задачи БЕЗ инкремента retry, ожидание 20с, повтор
- Нет задач: ожидание 5с, повтор

**Graceful shutdown (SIGTERM):**
1. Установить running = False
2. Отменить heartbeat
3. Вернуть задачу в очередь БЕЗ инкремента retry (shutdown не считается ошибкой задачи)
4. Освободить прокси (статус "свободен")
5. Закрыть браузер
6. Закрыть пул БД

### Виртуальные дисплеи (Xvfb)

Каждый воркер получает выделенный виртуальный дисплей:
- Воркер 1 → DISPLAY=:99
- Воркер 2 → DISPLAY=:100
- Воркер N → DISPLAY=:98+N

Процессы Xvfb управляются в entrypoint.sh с корректным cleanup при EXIT/SIGTERM/SIGINT.

## Принципы разработки

**KISS (Keep It Simple, Stupid):**
- Простая архитектура без лишних абстракций
- Прямое подключение к БД без API-слоев
- Минимум внешних зависимостей
- Один воркер = одна задача = один прокси
- Случайный выбор прокси вместо сложных алгоритмов

**Отказоустойчивость:**
- Автоматический перезапуск упавших воркеров
- Возврат зависших задач в очередь через час
- Независимая работа воркеров
- Сохранение промежуточных результатов

## Критические исправления (история)

**2025-01: Исправлена логика блокировки/освобождения прокси**
- ❌ **Было:** Прокси блокировались при ошибках запуска браузера
- ✅ **Стало:** Прокси БЛОКИРУЮТСЯ только при детекторах 403/407 (реальная блокировка Авито)
- ✅ **Стало:** Прокси ОСВОБОЖДАЮТСЯ при ошибках браузера, timeout, капче (не вина прокси)
- **Файлы:** [main.py:224](container/worker/main.py#L224), [main.py:820](container/worker/main.py#L820)

**2025-01: Добавлена проверка MAX_RETRY_ATTEMPTS для детального парсинга**
- ❌ **Было:** Бесконечные retry при фатальных ошибках детального парсинга карточек
- ✅ **Стало:** После 3 попыток задача помечается как "ошибка"
- **Файлы:** [main.py:987-1001](container/worker/main.py#L987-L1001)

## Частые проблемы

1. **Отсутствует avito-library:** Воркер не запустится (режима заглушки нет) - проверить зависимости
2. **Слишком много соединений БД:** Убедиться что NUM_WORKERS × POOL_MAX_SIZE < 100
3. **Падения браузера:** Проверить что shm_size достаточен (6GB для 15 воркеров)
4. **Зависшие задачи:** Проверить работу heartbeat механизма
5. **Неправильный docker-compose.yml:** Использовать корневой docker-compose.yml, НЕ container/docker-compose.yml (удален)
6. **Истощение пула прокси:** Проверить что прокси НЕ блокируются при технических ошибках (только 403/407)
7. **Задачи зависают в очереди:** Проверить что счетчик retry работает для всех этапов (каталог + детальный парсинг)

## Полная документация

Полная спецификация алгоритмов и детали реализации: [docs/doc.md](docs/doc.md)
