# **Полная спецификация алгоритмов работы системы парсинга Авито**

## **ЭТАП 1: Подготовка инфраструктуры**

### **Шаг 1.1 - Структура базы данных**
Система требует PostgreSQL базу данных со следующими таблицами:

**Таблица задач** - хранит артикулы для парсинга, статус выполнения (новая, в работе, завершена, ошибка), время взятия задачи воркером, идентификатор воркера, время последнего heartbeat

**Таблица прокси** - хранит адреса прокси, статус (свободен, используется, заблокирован), идентификатор использующего воркера

**Таблица спаршенных карточек** - хранит данные объявлений, идентификатор объявления с Авито, связь с артикулом, все спаршенные поля карточки, время парсинга

**Таблица валидации** - хранит идентификатор объявления, тип валидации (механическая или ИИ), результат (прошло или нет), причина отклонения, время валидации

**Таблица истории обработки** - хранит артикулы, которые уже полностью обработаны, время обработки

Все таблицы должны иметь необходимые индексы для быстрого поиска по ключевым полям.

### **Шаг 1.2 - Развертывание на сервере**
Мастер-скрипт выполняет следующие действия:
- Проверяет наличие Docker, при отсутствии устанавливает
- Выполняет сборку контейнеров через docker compose build
- Запускает контейнеры с воркерами через docker compose up
- Воркеры при старте подключаются к БД и начинают слушать новые задачи

## **ЭТАП 2: Управление через локальные скрипты**
**Статус: ✅ РЕАЛИЗОВАНО**

Реализованные скрипты:
- `scripts/db_utils.py` - общий модуль для работы с БД
- `scripts/add_tasks.py` - загрузка артикулов из `scripts/data/urls.txt`
- `scripts/manage_proxies.py` - управление прокси из `scripts/data/proxies.txt`
- `scripts/clear_database.py` - интерактивная очистка таблиц
- `scripts/monitor.py` - мониторинг системы с параллельными запросами

Все скрипты работают в интерактивном режиме, используют батчевую вставку (1000 записей), атомарные транзакции и асинхронные запросы к БД.

### **Шаг 2.1 - Скрипт постановки задач**
При запуске скрипт:
- Проверяет наличие всех необходимых таблиц в БД, при отсутствии создает их
- Читает список артикулов из текстового файла
- Если включен параметр проверки - асинхронно запрашивает из БД уже обработанные артикулы и исключает их
- В зависимости от параметра либо добавляет новые задачи к существующим, либо очищает таблицу и загружает заново
- Каждый артикул записывается как отдельная задача со статусом "новая"

### **Шаг 2.2 - Скрипт управления прокси**
При запуске скрипт:
- Проверяет и создает необходимые таблицы
- Загружает список прокси из источника
- В зависимости от параметра либо добавляет к существующим, либо полностью перезаписывает
- Все прокси изначально имеют статус "свободен"

### **Шаг 2.3 - Скрипт очистки БД**
Позволяет гибко управлять состоянием БД:
- Может очистить все таблицы для полного сброса
- Может очистить выборочные таблицы
- Используется для перезапуска обработки или тестирования

### **Шаг 2.4 - Скрипт мониторинга**
Отображает текущее состояние системы:
- Количество задач в очереди, в работе, завершенных
- Статистику по прокси (свободные, используемые, заблокированные)
- Статистику валидации (процент прохождения)
- Активные воркеры и их текущие задачи

## **ЭТАП 3: Работа воркеров**
**Статус: ✅ РЕАЛИЗОВАНО**

Реализованные компоненты:
- `container/worker/config.py` - конфигурация из переменных окружения
- `container/worker/errors.py` - кастомные исключения для обработки ошибок
- `container/worker/database.py` - 12 функций работы с БД (атомарные операции)
- `container/worker/browser.py` - управление Playwright браузером
- `container/worker/main.py` - главный цикл воркера с полной реализацией

Ключевые особенности реализации:
- Независимые воркеры - координация только через PostgreSQL БД
- Атомарные операции с FOR UPDATE SKIP LOCKED
- Переиспользование браузера и прокси между задачами
- Graceful shutdown при SIGTERM
- Heartbeat механизм (обновление каждые 120 сек)
- Автоматическое восстановление зависших задач (timeout 1 час)
- Retry механизм (максимум 3 попытки на задачу)

### **Шаг 3.1 - Инициализация воркера**
При старте каждый воркер:
- Подключается к БД
- Вызывает механизм возврата "зависших" задач - проверяет задачи в статусе "в работе", где время последнего heartbeat больше часа назад, возвращает их в статус "новая"
- Готовится к обработке задач

### **Шаг 3.2 - Взятие задачи**
Воркер в цикле:
- Атомарно берет одну задачу со статусом "новая" (механизм должен гарантировать, что два воркера не возьмут одну задачу)
- Меняет статус на "в работе", записывает свой идентификатор и время взятия
- Если свободных задач нет - ждет и периодически проверяет

### **Шаг 3.3 - Взятие прокси**
- Воркер атомарно берет случайный прокси со статусом "свободен"
- Меняет его статус на "используется", записывает свой идентификатор
- Если свободных прокси нет - воркер останавливается и логирует ошибку, не берет новые задачи


Виртуальные дисплеи для браузеров
Для работы браузеров в контейнерах без GUI используются виртуальные дисплеи:
Каждый воркер получает свой отдельный виртуальный дисплей (Xvfb)
Количество виртуальных дисплеев равно количеству воркеров

### **Шаг 3.4 - Запуск браузера**
- Воркер запускает браузерную страницу с выбранным прокси
- Страница будет переиспользоваться максимально долго для всех переходов

### **Шаг 3.5 - Heartbeat механизм**
- Воркер запускает фоновый процесс, который каждые несколько минут обновляет время heartbeat для текущей задачи в БД
- Это позволяет отличать работающие воркеры от зависших

## **ЭТАП 4: Парсинг каталога**
**Статус: ✅ РЕАЛИЗОВАНО**

Реализация через паттерн "Оркестратор-Координатор":
- Оркестратор - `parse_catalog_until_complete` из avito-library
- Координатор - воркер обрабатывает запросы на новые страницы (PageRequest)
- Обмен через PageExchange (две асинхронные очереди)

Особенности парсинга:
- БЕЗ ограничения по страницам - парсим все страницы каталога
- Автоматическое решение капчи для детекторов: CAPTCHA_DETECTOR_ID, CONTINUE_BUTTON_DETECTOR_ID, PROXY_BLOCK_429_DETECTOR_ID
- Автоматическая смена прокси при блокировке (403/407)
- Retry логика с максимум 5 попытками на ошибку
- Параллельная работа orchestrator_task и coordinator_task через asyncio.gather()

### **Шаг 4.1 - Переход в каталог**
- Воркер использует метод библиотеки Авито для перехода на страницу каталога по артикулу
- Устанавливает фильтр по дате для актуальности объявлений
- После перехода обязательно вызывает детектор состояния страницы

### **Шаг 4.2 - Обработка результатов детектора**
В зависимости от результата детектора:
- **Прокси заблокирован (403/407)** - помечает прокси как "заблокирован" навсегда, освобождает задачу, берет новый прокси, начинает заново
- **Капча (continue_button, 429, geetest)** - вызывает функцию решения капчи из библиотеки, после успешного решения продолжает
- **Страница каталога загружена** - переходит к парсингу
- **Состояние не определено** - пропускает задачу, переходит к следующей на этой же странице браузера

### **Шаг 4.3 - Сбор объявлений**
- Использует метод библиотеки для парсинга всех страниц каталога
- Метод автоматически обрабатывает пагинацию и собирает все объявления
- Для каждого объявления собирает: идентификатор, название, описание, цену, ник продавца
- Сохраняет промежуточные результаты для возможности восстановления при сбое

### **Шаг 4.4 - Проверка существующих карточек**
Для каждого найденного объявления:
- Проверяет по идентификатору Авито, есть ли уже такая карточка в БД
- Если карточка есть - перезаписывает связь с артикулом на текущий
- Если карточки нет - запоминает для детального парсинга

## **ЭТАП 5: Валидация**

### **Шаг 5.1 - Механическая валидация**
Для всех собранных объявлений выполняет:

**Проверка текстов:**
- Проверяет название, описание и ник продавца на наличие стоп-слов
- Поиск ведется регистронезависимо, как отдельные слова
- Список стоп-слов включает различные вариации: "не оригинал", "аналог", "б/у", "бу", "б.у", "б у" и названия неоригинальных брендов
- Объявления со стоп-словами помечаются как непрошедшие валидацию

**Ценовой анализ:**
- Сортирует все объявления по цене
- Берет 20% самых дорогих (если меньше 5 объявлений - берет хотя бы одно самое дорогое)
- Вычисляет их среднюю цену, исключая явные выбросы
- Отсеивает объявления с ценой меньше 50% от этой средней

**Сохранение результатов:**
- Сохраняет в таблицу валидации информацию о каждом объявлении с типом "механическая"
- Результаты валидации с пояснениями сохраняются в JSONB поле таблицы

### **Шаг 5.2 - Валидация ИИ-агентом**
Объявления, прошедшие механическую валидацию:

**Подготовка запроса:**
- Формирует один запрос со всеми объявлениями по артикулу
- Включает тексты и цены для анализа

**Анализ ИИ:**
- ИИ проверяет тексты на скрытые признаки неоригинальности
- Анализирует ценовое распределение: находит 20% самых дорогих, считает среднюю, отсеивает дешевле 70% от средней
- Возвращает список прошедших с пояснениями по отклоненным

**Обработка результатов:**
- Записывает в таблицу валидации с типом "ИИ"
- Результаты анализа ИИ с пояснениями сохраняются в JSONB поле таблицы
- При ошибке ИИ - задача возвращается в очередь

## **ЭТАП 6: Детальный парсинг карточек**

### **Шаг 6.1 - Переход на карточку**
Для каждого объявления, прошедшего обе валидации:
- Воркер переходит на страницу объявления
- Вызывает детектор состояния страницы
- Обрабатывает результаты детектора аналогично каталогу

### **Шаг 6.2 - Парсинг данных карточки**
При успешном детекторе карточки:
- Парсит все доступные поля объявления
- Сохраняет данные в таблицу спаршенных карточек
- Обязательно сохраняет связь с артикулом
- Помечает время парсинга

## **ЭТАП 7: Завершение задачи**

### **Шаг 7.1 - Финализация**
После обработки всех объявлений по артикулу:
- Если парсинг прошел успешно (даже если 0 объявлений) - меняет статус задачи на "завершена"
- Записывает артикул в таблицу истории обработки
- Освобождает задачу

### **Шаг 7.2 - Переход к следующей задаче**
- Воркер не освобождает прокси и не закрывает страницу браузера
- Берет следующую задачу из очереди
- Продолжает работу на той же странице браузера

## **ЭТАП 8: Обработка сбоев**

### **Шаг 8.1 - Падение воркера**
- При падении воркер автоматически перезапускается контейнером
- При старте выполняет механизм возврата зависших задач
- Берет новую задачу и прокси

### **Шаг 8.2 - Фатальные ошибки**
При фатальных ошибках или блокировке прокси:
- Закрывает страницу браузера
- Освобождает или блокирует прокси
- Возвращает задачу в очередь или помечает как ошибку
- Начинает цикл заново

### **Шаг 8.3 - Отсутствие ресурсов**
- Если нет свободных прокси - воркер не берет задачи, логирует ошибку, ждет
- Если нет задач - воркер ждет появления новых

Система обеспечивает непрерывную работу с максимальным переиспользованием ресурсов и автоматическим восстановлением после сбоев.