Общее назначение
Этот модуль является оркестратором для парсера каталога Авито. Он реализует механизм повторных попыток парсинга при возникновении восстанавливаемых ошибок (captcha, rate limit, проблемы с прокси и т.д.).
Ключевые константы
MAX_PAGE_RETRIES = 5 — максимальное количество попыток получить страницу при ошибках
BATCH_PAGE_LIMIT = 5 — сколько страниц каталога обрабатывается за одну итерацию
RECOVERABLE_STATUSES — набор статусов ошибок, после которых имеет смысл делать повторную попытку (капча, блокировка прокси, rate limit и др.)
Архитектурные компоненты
1. Класс PageRequest (строки 33-40)
Это структура данных, описывающая запрос на новую страницу:
attempt — номер текущей попытки
status — статус последней попытки парсинга
details — дополнительная информация об ошибке
next_start_page — с какой страницы каталога нужно продолжить
2. Класс _PageExchange (строки 43-66)
Это механизм обмена сообщениями между оркестратором и внешним координатором страниц. Работает через две асинхронные очереди:
_requests — очередь запросов на новые страницы (от оркестратора к координатору)
_responses — очередь ответов со страницами (от координатора к оркестратору)
Методы:
request_page() — оркестратор отправляет запрос и ждёт, пока внешний координатор предоставит новую страницу Playwright
next_request() — координатор получает детали следующего запроса
supply_page() — координатор передаёт страницу в ответ на запрос
3. Глобальный объект _EXCHANGE (строка 68)
Единственный экземпляр _PageExchange, через который происходит всё взаимодействие. Может быть заменён через set_page_exchange() для тестирования.
Основная функция parse_catalog_until_complete (строки 98-218)
Это центральная функция модуля. Она запускает циклический процесс парсинга каталога с автоматическими повторными попытками.
Параметры:
page — начальная страница Playwright
catalog_url — URL каталога Авито
fields — какие поля извлекать из объявлений
max_pages — максимальное количество страниц для обработки
sort_by_date — сортировать ли по дате
include_html — включать ли HTML в результат
start_page — с какой страницы начать
Алгоритм работы:
1. Инициализация (строки 110-116):
- listings_acc — накопитель всех собранных объявлений
- total_processed_pages — счётчик обработанных страниц
- total_processed_cards — счётчик обработанных карточек
- attempt — счётчик попыток при ошибках
- current_page — текущая страница Playwright
- next_start_page — номер следующей страницы каталога
2. Главный цикл (строка 118): Цикл продолжается, пока не будет достигнут лимит страниц или не произойдёт фатальная ошибка. 3. Расчёт батча (строки 122-132):
Определяется, сколько страниц осталось обработать
Выбирается размер следующего батча (до BATCH_PAGE_LIMIT)
Это позволяет не обрабатывать больше страниц, чем нужно
4. Вызов базового парсера (строки 135-143):
listings, meta = await parse_catalog(
    current_page,
    catalog_url,
    fields=fields,
    max_pages=chunk_limit,  # батч, а не весь лимит
    ...
)
Вызывается низкоуровневый парсер, который обрабатывает батч страниц. 5. Аккумуляция результатов (строки 145-148):
Добавляются новые объявления к общему списку
Обновляются счётчики обработанных страниц и карточек
Сохраняется последняя метаинформация
6. Проверка на успех (строки 150-157): Если статус = SUCCESS, возвращается полный результат с пометкой completed=True. 7. Проверка лимита страниц (строки 159-168): Если достигнут max_pages, возвращается результат с текущим статусом. 8. Проверка на невосстанавливаемую ошибку (строки 170-177): Если ошибка не в списке RECOVERABLE_STATUSES, парсинг прекращается. 9. Проверка лимита попыток (строки 179-188): Если исчерпаны все попытки (attempt >= MAX_PAGE_RETRIES), возвращается результат с флагом attempts_exhausted=True. 10. Запрос новой страницы (строки 190-199):
Если ошибка восстанавливаемая и попытки ещё есть:
Вычисляется next_start_page — с какой страницы каталога продолжить
Создаётся объект PageRequest с деталями ошибки
Через _EXCHANGE.request_page() отправляется запрос во внешний координатор
Функция блокируется и ждёт, пока координатор не предоставит новую страницу Playwright (возможно, с другим прокси, после решения капчи и т.д.)
Полученная страница становится текущей, и цикл повторяется
Вспомогательная функция _compose_meta_result (строки 221-253)
Собирает финальную метаинформацию о результате парсинга: Логика:
Берёт базовую метаинформацию от последнего вызова parse_catalog
Добавляет информацию о том, завершён ли сбор полностью
Если попытки исчерпаны, добавляет соответствующее сообщение
Объединяет все детали в одну строку
Если completed=True, устанавливает статус SUCCESS независимо от исходного
Публичное API модуля
Модуль экспортирует (строки 70-76):
parse_catalog_until_complete — главная функция оркестратора
PageRequest — тип для описания запроса страницы
wait_for_page_request() — для координатора, чтобы получить запрос
supply_page() — для координатора, чтобы передать страницу
set_page_exchange() — для тестирования
Паттерн взаимодействия
Оркестратор работает в связке с внешним координатором страниц:
Оркестратор (steam.py)          Координатор (внешний код)
       │                                  │
       │  1. Начинает парсинг             │
       │     с исходной страницей         │
       │                                  │
       │  2. Ошибка (капча/rate limit)    │
       │                                  │
       │  3. request_page(PageRequest) ─→ │
       │     (блокируется)                │
       │                                  │ 4. Получает запрос
       │                                  │    через wait_for_page_request()
       │                                  │
       │                                  │ 5. Решает капчу / меняет прокси /
       │                                  │    ждёт rate limit
       │                                  │
       │  6. ←─ supply_page(new_page)     │
       │     (разблокируется)             │
       │                                  │
       │  7. Продолжает парсинг           │
       │     с новой страницей            │
Преимущества архитектуры
Разделение ответственности — оркестратор управляет логикой повторов, координатор — ресурсами (страницы, прокси)
Гибкость — координатор может решать проблемы любым способом (менять прокси, ждать, решать капчу вручную)
Прозрачность — оркестратор сообщает точную причину проблемы через PageRequest
Тестируемость — можно подменить _EXCHANGE для unit-тестов
Это продуманная архитектура для надёжного парсинга с автоматическим восстановлением после типичных проблем веб-скрейпинга.